pipeline {
    agent {
        kubernetes {
            yaml """
apiVersion: v1
kind: Pod
spec:
  containers:
  - name: python
    image: python:3.11-slim
    command:
    - sleep
    args:
    - 99d
    env:
    - name: GIT_SSL_NO_VERIFY
      value: "true"
  - name: docker
    image: docker:20-dind
    securityContext:
      privileged: true
    env:
    - name: DOCKER_TLS_CERTDIR
      value: ""
  - name: kubectl
    image: alpine/kubectl:latest
    command:
    - sleep
    args:
    - 99d
"""
        }
    }

    environment {
        // ACR ì„¤ì •
        DOCKER_REGISTRY = 'ossknowledgeregistry.azurecr.io'
        ACR_CREDENTIAL_ID = 'acr-credential'
        IMAGE_NAME = 'oss-knowledge-embedding-server'
        
        // GitLab ë° GitOps ì„¤ì •
        GITLAB_URL = 'https://gitlab.4.230.158.187.nip.io'
        GITOPS_REPO = 'oss-ai-vtf/oss-knowledge-gitops'
        NAMESPACE_DEV = 'oss-knowledge-embedding-dev'
        NAMESPACE_PROD = 'oss-knowledge-embedding-prod'
        GITLAB_TOKEN = credentials('gitlab-token')
        
        // Git SSL ì„¤ì •
        GIT_SSL_NO_VERIFY = 'true'
    }
    
    stages {
        stage('Checkout') {
            steps {
                echo "ðŸ“„ Checking out source code..."
                script {
                    // Git SSL ê²€ì¦ ì™„ì „ ë¹„í™œì„±í™”
                    sh '''
                        git config --global http.sslVerify false
                        git config --global http.postBuffer 524288000
                        git config --global http.lowSpeedLimit 0
                        git config --global http.lowSpeedTime 999999
                        git config --global http.version HTTP/1.1
                        git config --global user.email "jenkins@oss-knowledge.com"
                        git config --global user.name "Jenkins CI/CD"
                        echo "Git SSL verification disabled and user configured"
                    '''
                    
                    // í˜„ìž¬ ë¸Œëžœì¹˜ì™€ ì»¤ë°‹ ì •ë³´ í™•ì¸
                    def actualBranch = env.BRANCH_NAME ?: 'main'
                    if (env.GIT_BRANCH && env.GIT_BRANCH.startsWith('origin/')) {
                        actualBranch = env.GIT_BRANCH.replaceAll('origin/', '')
                    }
                    echo "Branch: ${actualBranch}"
                    echo "Commit: ${env.GIT_COMMIT ?: 'unknown'}"
                }
            }
        }
        
        stage('Test & Validate') {
            steps {
                container('python') {
                    script {
                        sh '''
                            echo "ðŸ Using Python version:"
                            python --version
                            pip --version
                            
                            echo "ðŸ“¦ Installing dependencies..."
                            apt-get update && apt-get install -y build-essential curl
                            pip install --no-cache-dir -r requirements.txt
                            
                            echo "ðŸ§ª Running tests..."
                            python -m pytest tests/ -v --tb=short || echo "No tests found - skipping"
                            
                            echo "âœ… Basic syntax and import checks..."
                            # Set dummy environment variables for testing
                            export OPENAI_API_KEY="dummy-key-for-testing"
                            export NEO4J_PASSWORD="dummy-password-for-testing"
                            export QDRANT_URL="http://localhost:6333"
                            export NEO4J_URI="neo4j://localhost:7687"
                            export NEO4J_USERNAME="neo4j"
                            
                            # Test imports without actually starting the server
                            python -c "
import os
# Set all required environment variables for testing
os.environ.setdefault('OPENAI_API_KEY', 'dummy-key-for-testing')
os.environ.setdefault('NEO4J_PASSWORD', 'dummy-password-for-testing')
os.environ.setdefault('QDRANT_URL', 'http://localhost:6333')
os.environ.setdefault('NEO4J_URI', 'neo4j://localhost:7687')
os.environ.setdefault('NEO4J_USER', 'neo4j')
os.environ.setdefault('NEO4J_USERNAME', 'neo4j')
# Import and test
import app.config
import app.main
print('âœ… Application imports successfully')
"
                            
                            # Compile Python files
                            python -m py_compile app/main.py
                            python -m py_compile app/config/settings.py
                            
                            echo "âœ… Validation completed"
                        '''
                    }
                }
            }
        }
        
        stage('Build & Push to ACR') {
            steps {
                container('docker') {
                    script {
                        // Branch name í™•ì¸ ë° ê¸°ë³¸ê°’ ì„¤ì •
                        def branchName = env.BRANCH_NAME ?: 'main'
                        if (env.GIT_BRANCH && env.GIT_BRANCH.startsWith('origin/')) {
                            branchName = env.GIT_BRANCH.replaceAll('origin/', '')
                        }
                        def imageTag = branchName == 'main' ? 'latest' : branchName.replaceAll('[^a-zA-Z0-9._-]', '-')
                        def buildTag = "${env.BUILD_NUMBER}-${imageTag}"
                        def fullImageName = "${DOCKER_REGISTRY}/${IMAGE_NAME}:${buildTag}"
                        def latestImageName = "${DOCKER_REGISTRY}/${IMAGE_NAME}:${imageTag}"
                        
                        echo "ðŸ³ Building Docker image..."
                        echo "Branch: ${branchName}, Tag: ${imageTag}, Build Tag: ${buildTag}"
                        echo "Image: ${fullImageName}"
                        
                        // ACR ë¡œê·¸ì¸ ë° ì´ë¯¸ì§€ ë¹Œë“œ/í‘¸ì‹œ
                        withCredentials([usernamePassword(
                            credentialsId: ACR_CREDENTIAL_ID,
                            usernameVariable: 'ACR_USERNAME',
                            passwordVariable: 'ACR_PASSWORD'
                        )]) {
                            sh """
                                # Docker ë°ëª¬ ì¤€ë¹„ ëŒ€ê¸°
                                until docker info; do
                                    echo "Waiting for Docker daemon..."
                                    sleep 2
                                done
                                
                                # ACR ë¡œê·¸ì¸
                                echo "ðŸ” Logging in to ACR..."
                                echo \$ACR_PASSWORD | docker login ${DOCKER_REGISTRY} -u \$ACR_USERNAME --password-stdin
                                
                                # Docker ì´ë¯¸ì§€ ë¹Œë“œ
                                echo "ðŸ› ï¸ Building Docker image..."
                                docker build -t ${fullImageName} -t ${latestImageName} .
                                
                                # ì´ë¯¸ì§€ ì •ë³´ í™•ì¸
                                docker images | grep ${IMAGE_NAME}
                                
                                # ACRì— í‘¸ì‹œ
                                echo "ðŸš€ Pushing to ACR..."
                                docker push ${fullImageName}
                                docker push ${latestImageName}
                                
                                # ë¡œê·¸ì•„ì›ƒ ë° ì •ë¦¬
                                docker logout ${DOCKER_REGISTRY}
                                docker rmi ${fullImageName} ${latestImageName} || true
                                
                                echo "âœ… Successfully pushed to ACR!"
                            """
                        }
                        
                        // í™˜ê²½ ë³€ìˆ˜ ì„¤ì • (ë‹¤ìŒ ìŠ¤í…Œì´ì§€ì—ì„œ ì‚¬ìš©)
                        env.FINAL_IMAGE_TAG = buildTag
                        env.FINAL_IMAGE_NAME = fullImageName
                    }
                }
            }
        }
        
        stage('Update GitOps Repository') {
            when {
                anyOf {
                    branch 'main'
                    branch 'develop'
                    branch 'master'
                }
            }
            steps {
                container('kubectl') {
                    script {
                        updateGitOpsRepository()
                    }
                }
            }
        }
        
        stage('Trigger ArgoCD Sync') {
            when {
                anyOf {
                    branch 'develop'
                    branch 'main'
                    branch 'master'
                }
            }
            steps {
                container('kubectl') {
                    script {
                        echo "ðŸ”„ Checking ArgoCD Applications status..."
                        
                        sh """
                            # ArgoCD Applications ì¡´ìž¬ í™•ì¸
                            echo "Checking for dev application..."
                            if kubectl get application oss-knowledge-embedding-server-dev -n argocd; then
                                echo "âœ… Dev ArgoCD Application found"
                                
                                # ìˆ˜ë™ ë™ê¸°í™” íŠ¸ë¦¬ê±°
                                kubectl patch application oss-knowledge-embedding-server-dev -n argocd \\
                                --type='json' \\
                                -p='[{"op":"replace","path":"/operation","value":{"sync":{"syncStrategy":{"apply":{"force":true}}}}}]' || \\
                                echo "âš ï¸ Manual sync required via ArgoCD UI"
                            else
                                echo "âš ï¸ Dev ArgoCD Application not found. Please create it manually:"
                                echo "Application Name: oss-knowledge-embedding-server-dev"
                                echo "Repository: ${GITLAB_URL}/${GITOPS_REPO}"
                                echo "Path: backend/embedding-server/overlays/dev"
                                echo "Namespace: ${NAMESPACE_DEV}"
                            fi
                            
                            echo "Checking for prod application..."
                            if kubectl get application oss-knowledge-embedding-server-prod -n argocd; then
                                echo "âœ… Prod ArgoCD Application found"
                                
                                # ìˆ˜ë™ ë™ê¸°í™” íŠ¸ë¦¬ê±° (main ë¸Œëžœì¹˜ë§Œ)
                                if [ "${env.BRANCH_NAME}" = "main" ]; then
                                    kubectl patch application oss-knowledge-embedding-server-prod -n argocd \\
                                    --type='json' \\
                                    -p='[{"op":"replace","path":"/operation","value":{"sync":{"syncStrategy":{"apply":{"force":true}}}}}]' || \\
                                    echo "âš ï¸ Manual sync required via ArgoCD UI"
                                fi
                            else
                                echo "âš ï¸ Prod ArgoCD Application not found. Please create it manually:"
                                echo "Application Name: oss-knowledge-embedding-server-prod"
                                echo "Repository: ${GITLAB_URL}/${GITOPS_REPO}"
                                echo "Path: backend/embedding-server/overlays/prod"
                                echo "Namespace: ${NAMESPACE_PROD}"
                            fi
                        """
                    }
                }
            }
        }
    }
    
    post {
        success {
            script {
                echo 'âœ… Pipeline completed successfully!'
                echo "ðŸ³ Image pushed to ACR: ${env.FINAL_IMAGE_NAME ?: 'N/A'}"
                echo "ðŸ·ï¸ Tag: ${env.FINAL_IMAGE_TAG ?: 'N/A'}"
                echo "ðŸ”— ArgoCD: http://argocd.4.230.158.187.nip.io"
                echo "ðŸ”— Dev: http://oss-knowledge-embedding-dev.4.230.158.187.nip.io"
                echo "ðŸ”— Prod: http://oss-knowledge-embedding.4.230.158.187.nip.io"
            }
        }
        failure {
            script {
                echo 'âŒ Pipeline failed!'
                echo 'ðŸ’¡ Check the stage logs above for detailed error information'
            }
        }
    }
}

def updateGitOpsRepository() {
    def imageTag = env.FINAL_IMAGE_TAG
    def branchName = env.BRANCH_NAME ?: 'main'
    
    withCredentials([string(credentialsId: 'gitlab-token', variable: 'GITLAB_TOKEN')]) {
        sh """
            echo "ðŸ”„ Updating GitOps repository..."
            
            # Git ì„¤ì • - SSL ê²€ì¦ ë¹„í™œì„±í™”
            git config --global user.email "jenkins@oss-knowledge.com"
            git config --global user.name "Jenkins CI/CD"
            git config --global http.sslVerify false
            git config --global http.postBuffer 524288000
            
            # ìž„ì‹œ ë””ë ‰í† ë¦¬ ìƒì„±
            rm -rf gitops-temp || true
            
            # GitOps ë ˆí¬ì§€í† ë¦¬ í´ë¡ 
            echo "ðŸ“¥ Cloning GitOps repository..."
            git clone --config http.sslVerify=false https://oauth2:\$GITLAB_TOKEN@gitlab.4.230.158.187.nip.io/${GITOPS_REPO}.git gitops-temp
            cd gitops-temp
            
            # ë©”ì¸ ë¸Œëžœì¹˜ë¡œ ì²´í¬ì•„ì›ƒ
            git checkout main 2>/dev/null || git checkout master 2>/dev/null || git checkout -b main
            
            # ê°œë°œ í™˜ê²½ ì´ë¯¸ì§€ ì—…ë°ì´íŠ¸
            if [ -f "backend/embedding-server/overlays/dev/kustomization.yaml" ]; then
                echo "ðŸ“ Updating dev environment image to ${imageTag}..."
                
                # ê¸°ì¡´ ì´ë¯¸ì§€ ì„¤ì • ì œê±° ë° ìƒˆë¡œìš´ ì„¤ì • ì¶”ê°€
                sed -i '/^images:/,/^[a-zA-Z]/{ /^[a-zA-Z]/!d; }' backend/embedding-server/overlays/dev/kustomization.yaml
                sed -i '/^images:/d' backend/embedding-server/overlays/dev/kustomization.yaml
                
                cat >> backend/embedding-server/overlays/dev/kustomization.yaml << EOF
images:
- name: ${IMAGE_NAME}
  newName: ${DOCKER_REGISTRY}/${IMAGE_NAME}
  newTag: ${imageTag}
EOF
            else
                echo "âš ï¸ Dev kustomization.yaml not found"
            fi
            
            # í”„ë¡œë•ì…˜ í™˜ê²½ ì´ë¯¸ì§€ ì—…ë°ì´íŠ¸ (main ë¸Œëžœì¹˜ë§Œ)
            if [ "${branchName}" = "main" ] && [ -f "backend/embedding-server/overlays/prod/kustomization.yaml" ]; then
                echo "ðŸ“ Updating prod environment image to ${imageTag}..."
                
                # ê¸°ì¡´ ì´ë¯¸ì§€ ì„¤ì • ì œê±° ë° ìƒˆë¡œìš´ ì„¤ì • ì¶”ê°€
                sed -i '/^images:/,/^[a-zA-Z]/{ /^[a-zA-Z]/!d; }' backend/embedding-server/overlays/prod/kustomization.yaml
                sed -i '/^images:/d' backend/embedding-server/overlays/prod/kustomization.yaml
                
                cat >> backend/embedding-server/overlays/prod/kustomization.yaml << EOF
images:
- name: ${IMAGE_NAME}
  newName: ${DOCKER_REGISTRY}/${IMAGE_NAME}
  newTag: ${imageTag}
EOF
            fi
            
            # ë³€ê²½ì‚¬í•­ í™•ì¸ ë° ì»¤ë°‹
            echo "ðŸ“‹ Changes to be committed:"
            git status
            
            git add .
            if git diff --cached --quiet; then
                echo "â„¹ï¸ No changes to commit"
            else
                git commit -m "ðŸš€ Update ${IMAGE_NAME} image to ${imageTag} (Build #${env.BUILD_NUMBER})"
                git -c http.sslVerify=false push origin HEAD
                echo "âœ… GitOps repository updated successfully!"
            fi
            
            # ì •ë¦¬
            cd ..
            rm -rf gitops-temp
        """
    }
}