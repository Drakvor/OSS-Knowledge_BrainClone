pipeline {
    agent {
        kubernetes {
            yaml """
apiVersion: v1
kind: Pod
spec:
  containers:
  - name: nodejs
    image: node:18
    command:
    - sleep
    args:
    - 99d
    env:
    - name: GIT_SSL_NO_VERIFY
      value: "true"
  - name: docker
    image: docker:20-dind
    securityContext:
      privileged: true
    env:
    - name: DOCKER_TLS_CERTDIR
      value: ""
  - name: kubectl
    image: alpine/kubectl:latest
    command:
    - sleep
    args:
    - 99d
"""
        }
    }

    environment {
        // ACR ì„¤ì •
        DOCKER_REGISTRY = 'ossknowledgeregistry.azurecr.io'
        ACR_CREDENTIAL_ID = 'acr-credential'
        IMAGE_NAME = 'oss-knowledge-front'
        
        // GitLab ë° GitOps ì„¤ì •
        GITLAB_URL = 'https://gitlab.4.230.158.187.nip.io'
        GITOPS_REPO = 'oss-ai-vtf/oss-knowledge-gitops'
        NAMESPACE = 'oss-knowledge-front-dev'
        GITLAB_TOKEN = credentials('gitlab-token')
        
        // Git SSL ì„¤ì •
        GIT_SSL_NO_VERIFY = 'true'
    }
    
    stages {
        stage('Checkout') {
            steps {
                echo "ðŸ“„ Checking out source code..."
                script {
                    // Git SSL ê²€ì¦ ì™„ì „ ë¹„í™œì„±í™”
                    sh '''
                        git config --global http.sslVerify false
                        git config --global http.postBuffer 524288000
                        git config --global http.lowSpeedLimit 0
                        git config --global http.lowSpeedTime 999999
                        git config --global http.version HTTP/1.1
                        git config --global user.email "jenkins@oss-knowledge.com"
                        git config --global user.name "Jenkins CI/CD"
                        echo "Git SSL verification disabled and user configured"
                    '''
                    
                    // í˜„ìž¬ ë¸Œëžœì¹˜ì™€ ì»¤ë°‹ ì •ë³´ í™•ì¸
                    def actualBranch = env.BRANCH_NAME ?: 'main'
                    if (env.GIT_BRANCH && env.GIT_BRANCH.startsWith('origin/')) {
                        actualBranch = env.GIT_BRANCH.replaceAll('origin/', '')
                    }
                    echo "Branch: ${actualBranch}"
                    echo "Commit: ${env.GIT_COMMIT ?: 'unknown'}"
                }
            }
        }
        
        stage('Install Dependencies & Build') {
            steps {
                container('nodejs') {
                    script {
                        // Jenkinsì— ì„¤ì¹˜ëœ NodeJS ì‚¬ìš© (ì •í™•í•œ ì´ë¦„: NodeJS-24.6.0)
                        try {
                            def nodejs = tool name: 'NodeJS-24.6.0', type: 'jenkins.plugins.nodejs.tools.NodeJSInstallation'
                            env.PATH = "${nodejs}/bin:${env.PATH}"
                        } catch (Exception e) {
                            echo "âš ï¸ NodeJS tool not found, using system Node.js"
                            echo "Error: ${e.message}"
                        }
                        
                        sh '''
                            echo "ðŸ”§ Using NodeJS version:"
                            node --version
                            npm --version
                            
                            echo "ðŸ“¦ Installing dependencies..."
                            npm ci
                            
                            echo "ðŸ—ï¸ Building application..."
                            npm run build
                            
                            echo "âœ… Build completed. Contents:"
                            ls -la dist/
                            du -sh dist/
                        '''
                    }
                }
            }
        }
        
        stage('Build & Push to ACR') {
            steps {
                container('docker') {
                    script {
                        // Branch name í™•ì¸ ë° ê¸°ë³¸ê°’ ì„¤ì •
                        def branchName = env.BRANCH_NAME ?: 'main'
                        if (env.GIT_BRANCH && env.GIT_BRANCH.startsWith('origin/')) {
                            branchName = env.GIT_BRANCH.replaceAll('origin/', '')
                        }
                        def imageTag = branchName == 'main' ? 'latest' : branchName.replaceAll('[^a-zA-Z0-9._-]', '-')
                        def buildTag = "${env.BUILD_NUMBER}-${imageTag}"
                        def fullImageName = "${DOCKER_REGISTRY}/${IMAGE_NAME}:${buildTag}"
                        def latestImageName = "${DOCKER_REGISTRY}/${IMAGE_NAME}:${imageTag}"
                        
                        echo "ðŸ³ Building Docker image..."
                        echo "Branch: ${branchName}, Tag: ${imageTag}, Build Tag: ${buildTag}"
                        echo "Image: ${fullImageName}"
                        
                        // ACR ë¡œê·¸ì¸ ë° ì´ë¯¸ì§€ ë¹Œë“œ/í‘¸ì‹œ
                        withCredentials([usernamePassword(
                            credentialsId: ACR_CREDENTIAL_ID,
                            usernameVariable: 'ACR_USERNAME',
                            passwordVariable: 'ACR_PASSWORD'
                        )]) {
                            sh """
                                # Docker ë°ëª¬ ì¤€ë¹„ ëŒ€ê¸°
                                until docker info; do
                                    echo "Waiting for Docker daemon..."
                                    sleep 2
                                done
                                
                                # ACR ë¡œê·¸ì¸
                                echo "ðŸ” Logging in to ACR..."
                                echo \$ACR_PASSWORD | docker login ${DOCKER_REGISTRY} -u \$ACR_USERNAME --password-stdin
                                
                                # Docker ì´ë¯¸ì§€ ë¹Œë“œ (í™˜ê²½ë³€ìˆ˜ ì „ë‹¬)
                                echo "ðŸ› ï¸ Building Docker image..."
                                docker build \\
                                    --build-arg VITE_API_BASE_URL=http://oss-knowledge-meta-api-dev.4.230.158.187.nip.io \\
                                    --build-arg VITE_EMBEDDING_API_BASE_URL=http://oss-knowledge-embedding-dev.4.230.158.187.nip.io \\
                                    --build-arg VITE_SEARCH_API_BASE_URL=http://oss-knowledge-search-dev.4.230.158.187.nip.io \\
                                    -t ${fullImageName} -t ${latestImageName} .
                                
                                # ì´ë¯¸ì§€ ì •ë³´ í™•ì¸
                                docker images | grep ${IMAGE_NAME}
                                
                                # ACRì— í‘¸ì‹œ
                                echo "ðŸš€ Pushing to ACR..."
                                docker push ${fullImageName}
                                docker push ${latestImageName}
                                
                                # ë¡œê·¸ì•„ì›ƒ ë° ì •ë¦¬
                                docker logout ${DOCKER_REGISTRY}
                                docker rmi ${fullImageName} ${latestImageName} || true
                                
                                echo "âœ… Successfully pushed to ACR!"
                            """
                        }
                        
                        // í™˜ê²½ ë³€ìˆ˜ ì„¤ì • (ë‹¤ìŒ ìŠ¤í…Œì´ì§€ì—ì„œ ì‚¬ìš©)
                        env.FINAL_IMAGE_TAG = buildTag
                        env.FINAL_IMAGE_NAME = fullImageName
                    }
                }
            }
        }
        
        stage('Update GitOps Repository') {
            when {
                anyOf {
                    branch 'main'
                    branch 'develop'
                    branch 'master'
                    expression { env.BRANCH_NAME == 'main' }
                    expression { env.GIT_BRANCH == 'origin/main' }
                }
            }
            steps {
                script {
                    updateGitOpsRepository()
                }
            }
        }
        
        stage('Trigger ArgoCD Sync') {
            when {
                anyOf {
                    branch 'develop'
                    branch 'main'
                    branch 'master'
                }
            }
            steps {
                script {
                    echo "ðŸ”„ Checking ArgoCD Application status..."
                    
                    sh """
                        # ArgoCD Application ì¡´ìž¬ í™•ì¸
                        if kubectl get application oss-knowledge-front-dev -n argocd; then
                            echo "âœ… ArgoCD Application found"
                            
                            # ìˆ˜ë™ ë™ê¸°í™” íŠ¸ë¦¬ê±°
                            kubectl patch application oss-knowledge-front-dev -n argocd \\
                            --type='json' \\
                            -p='[{"op":"replace","path":"/operation","value":{"sync":{"syncStrategy":{"apply":{"force":true}}}}}]' || \\
                            echo "âš ï¸ Manual sync required via ArgoCD UI"
                        else
                            echo "âš ï¸ ArgoCD Application not found. Please create it manually:"
                            echo "Application Name: oss-knowledge-front-dev"
                            echo "Repository: ${GITLAB_URL}/${GITOPS_REPO}"
                            echo "Path: front/overlays/dev"
                            echo "Namespace: ${NAMESPACE}"
                        fi
                    """
                }
            }
        }
    }
    
    post {
        success {
            script {
                echo 'âœ… Pipeline completed successfully!'
                echo "ðŸ³ Image pushed to ACR: ${env.FINAL_IMAGE_NAME ?: 'N/A'}"
                echo "ðŸ·ï¸ Tag: ${env.FINAL_IMAGE_TAG ?: 'N/A'}"
                echo "ðŸ”— ArgoCD: http://argocd.4.230.158.187.nip.io"
            }
        }
        failure {
            script {
                echo 'âŒ Pipeline failed!'
                echo 'ðŸ’¡ Check the stage logs above for detailed error information'
            }
        }
    }
}

def updateGitOpsRepository() {
    def imageTag = env.FINAL_IMAGE_TAG
    
    withCredentials([string(credentialsId: 'gitlab-token', variable: 'GITLAB_TOKEN')]) {
        sh """
            echo "ðŸ”„ Updating GitOps repository..."
            
            # Git ì„¤ì • - SSL ê²€ì¦ ë¹„í™œì„±í™”
            git config --global user.email "jenkins@oss-knowledge.com"
            git config --global user.name "Jenkins CI/CD"
            git config --global http.sslVerify false
            git config --global http.postBuffer 524288000
            
            # ìž„ì‹œ ë””ë ‰í† ë¦¬ ìƒì„±
            rm -rf gitops-temp || true
            
            # GitOps ë ˆí¬ì§€í† ë¦¬ í´ë¡ 
            echo "ðŸ“¥ Cloning GitOps repository..."
            git clone --config http.sslVerify=false https://oauth2:\$GITLAB_TOKEN@gitlab.4.230.158.187.nip.io/${GITOPS_REPO}.git gitops-temp
            cd gitops-temp
            
            # ë©”ì¸ ë¸Œëžœì¹˜ë¡œ ì²´í¬ì•„ì›ƒ
            git checkout main 2>/dev/null || git checkout master 2>/dev/null || git checkout -b main
            
            # GitOps êµ¬ì¡° ìƒì„±
            mkdir -p front/base
            mkdir -p front/overlays/dev
            
            # Base kustomization ìƒì„±
            if [ ! -f "front/base/kustomization.yaml" ]; then
                cat > front/base/kustomization.yaml << 'EOF'
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

resources:
- deployment.yaml
- service.yaml
- ingress.yaml

commonLabels:
  app: oss-knowledge-front
EOF
            fi
            
            # Dev overlay kustomization ì—…ë°ì´íŠ¸
            cat > front/overlays/dev/kustomization.yaml << EOF
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

resources:
- ../../base

namespace: ${NAMESPACE}

images:
- name: ${IMAGE_NAME}
  newName: ${DOCKER_REGISTRY}/${IMAGE_NAME}
  newTag: ${imageTag}

commonLabels:
  environment: dev
EOF
            
            # ë³€ê²½ì‚¬í•­ í™•ì¸ ë° ì»¤ë°‹
            echo "ðŸ“‹ Changes to be committed:"
            git status
            
            git add .
            if git diff --cached --quiet; then
                echo "â„¹ï¸ No changes to commit"
            else
                git commit -m "ðŸš€ Update ${IMAGE_NAME} image to ${imageTag} (Build #${env.BUILD_NUMBER})"
                git -c http.sslVerify=false push origin HEAD
                echo "âœ… GitOps repository updated successfully!"
            fi
            
            # ì •ë¦¬
            cd ..
            rm -rf gitops-temp
        """
    }
}